patch-package
--- a/node_modules/graphql-tools/dist/stitching/schemaRecreation.js
+++ b/node_modules/graphql-tools/dist/stitching/schemaRecreation.js
@@ -68,6 +68,12 @@ function recreateType(type, resolveType, keepResolvers) {
                 astNode: value.astNode,
             };
         });
+        // Patch type in wrapped schema to pass-through the value as-is, so the wrapping schema's `serialize` function
+        // will be able to do its original work. Otherwise the wrapping schema will be unable to work with the already
+        // serialized value.
+        type.serialize = function patchedSerialize(value) {
+            return value;
+        }
         return new graphql_1.GraphQLEnumType({
             name: type.name,
             description: type.description,
--- a/node_modules/graphql-tools/dist/transforms/visitSchema.js
+++ b/node_modules/graphql-tools/dist/transforms/visitSchema.js
@@ -29,7 +29,20 @@ function visitSchema(schema, visitor, stripResolvers) {
     var mutationType = schema.getMutationType();
     var subscriptionType = schema.getSubscriptionType();
     var typeMap = schema.getTypeMap();
-    Object.keys(typeMap).map(function (typeName) {
+
+    // Move interfaces to the front of the list, as the call-site may need to
+    // transform both interface and object types and thus need to be able to
+    // refer to the transformed interface types when creating the transformed
+    // object types.
+    var typeKeys = Object.keys(typeMap).sort(function (typeName) {
+      if (typeMap[typeName] instanceof graphql_1.GraphQLInterfaceType) {
+        return -1;
+      } else {
+        return 1;
+      }
+    });
+
+    typeKeys.map(function (typeName) {
         var type = typeMap[typeName];
         if (graphql_1.isNamedType(type) && graphql_1.getNamedType(type).name.slice(0, 2) !== '__') {
             var specifiers = getTypeSpecifiers(type, schema);
